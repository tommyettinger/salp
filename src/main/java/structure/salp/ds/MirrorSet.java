/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
package structure.salp.ds;

import sarong.RNG;
import sarong.util.CrossHash;
import structure.salp.util.ArrayTools;
import structure.salp.util.GwtIncompatible;

import java.io.Serializable;
import java.util.*;

/**
 * A bi-directional mapping of unique objects to and from their positions in the data structure's stable ordering.
 * Useful for various indirection techniques where you want to be able to retrieve a value in several ways, such as with
 * multiple MirrorSets all sharing the same ordering but with different types for keys.
 * <br>
 * Originally, this started as a generic linked hash map with with a fast implementation, originally from fastutil as
 * Object2IntLinkedOpenHashMap but modified to support indexed access. The code is extremely close to {@link OrderedMap},
 * and like OrderedMap you can look up keys by index, but this is specialized to int values which it can automatically assign.
 * <br>
 * <p>Instances of this class use a hash table to represent a map. The table is filled up to a specified <em>load factor</em>, and then doubled in size to accommodate new entries. If the table is
 * emptied below <em>one fourth</em> of the load factor, it is halved in size. However, halving is not performed when deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>Note that {@link #clear()} does not modify the hash table size. Rather, a family of {@linkplain #trim() trimming methods} lets you control the size of the table; this is particularly useful if
 * you reuse instances of this class.
 * </p>
 * <p>Iterators generated by this map will enumerate pairs in the same order in which they have been added to the map (addition of pairs whose key is already present in the set does not change the
 * iteration order). Note that this order has nothing in common with the natural order of the keys. The order is kept by means of a int-specialized list, {@link IntVLA}, and is modifiable with this
 * class' {@link #reorder(int...)} and {@link #shuffle(RNG)} methods, among other tools.
 * </p>
 * <p>This class implements the interface of a sorted map, so to allow easy access of the iteration order: for instance, you can get the first key in iteration order with {@code firstKey()} without
 * having to create an iterator; however, this class partially violates the {@link SortedMap} contract because all submap methods throw an exception and {@link #comparator()} returns always
 * <code>null</code>.
 * </p>
 * <p>
 * Additional methods, such as <code>getAndMoveToFirst()</code>, make it easy to use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>The iterators provided by the views of this class using are type-specific {@linkplain ListIterator list iterators}, and can be started at any element <em>which is a key of the map</em>,
 * or a {@link NoSuchElementException} exception will be thrown. If, however, the provided element is not the first or last key in the set, the first access to the list index will require linear time,
 * as in the worst case the entire key set must be scanned in iteration order to retrieve the positional index of the starting key.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.
 * <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)
 */
public class MirrorSet<K> implements SortedMap<K, Integer>, Iterable<K>, Serializable, Cloneable {
    private static final long serialVersionUID = 0L;
    /**
     * The array of keys.
     */
    protected K[] key;
    /**
     * The array of values.
     */
    protected int[] value;
    /**
     * The mask for wrapping a position counter.
     */
    protected int mask;
    /**
     * Whether this set contains the key zero.
     */
    protected boolean containsNullKey;
    /**
     * The index of the first entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int first = -1;
    /**
     * The index of the last entry in iteration order. It is valid iff {@link #size} is nonzero; otherwise, it contains -1.
     */
    protected int last = -1;
    /*
     * For each entry, the next and the previous entry in iteration order, stored as <code>((prev & 0xFFFFFFFFL) << 32) | (next & 0xFFFFFFFFL)</code>. The first entry contains predecessor -1, and the
     * last entry contains successor -1.
     */
    //protected long[] link;
    protected IntVLA order;
    /**
     * The current table size.
     */
    protected int n;
    /**
     * Threshold after which we rehash. It must be the table size times {@link #f}.
     */
    protected int maxFill;
    /**
     * Number of entries in the set (including the key zero, if present).
     */
    protected int size;
    /**
     * The acceptable load factor.
     */
    public final float f;
    /**
     * Cached set of entries.
     */
    protected volatile MapEntrySet entries;
    /**
     * Cached set of keys.
     */
    protected volatile KeySet keys;
    /**
     * Cached collection of values.
     */
    protected volatile Collection<Integer> values;
    /**
     * Default return value.
     */
    protected final int defRetValue = -1;

    /**
     * The initial default size of a hash table.
     */
    public static final int DEFAULT_INITIAL_SIZE = 16;
    /**
     * The default load factor of a hash table.
     */
    public static final float DEFAULT_LOAD_FACTOR = .5f; // .375f // .1875f; // .75f;
    /**
     * The load factor for a (usually small) table that is meant to be particularly fast.
     */
    public static final float FAST_LOAD_FACTOR = .5f;
    /**
     * The load factor for a (usually very small) table that is meant to be extremely fast.
     */
    public static final float VERY_FAST_LOAD_FACTOR = .25f;

    protected CrossHash.IHasher hasher = null;

    /**
     * Creates a new MirrorSet.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */

    @SuppressWarnings("unchecked")
    public MirrorSet(final int expected, final float f) {
        if (f <= 0 || f > 1)
            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
        if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");
        this.f = f;
        n = arraySize(expected, f);
        mask = n - 1;
        maxFill = maxFill(n, f);
        key = (K[]) new Object[n + 1];
        value = new int[n + 1];
        //link = new long[n + 1];
        order = new IntVLA(expected);
        hasher = CrossHash.defaultHasher;
    }

    /**
     * Creates a new MirrorSet with 0.5f as load factor.
     *
     * @param expected the expected number of elements in the MirrorSet.
     */
    public MirrorSet(final int expected) {
        this(expected, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new MirrorSet with initial expected 16 entries and 0.5f as load factor.
     */
    public MirrorSet() {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new MirrorSet copying a given one.
     *
     * @param m a {@link Map} to be copied into the new MirrorSet.
     * @param f the load factor.
     */
    public MirrorSet(final Map<? extends K, ? extends Integer> m, final float f) {
        this(m.size(), f);
        putAll(m);
    }

    /**
     * Creates a new MirrorSet with 0.5f as load factor copying a given one.
     *
     * @param m a {@link Map} to be copied into the new MirrorSet.
     */
    public MirrorSet(final Map<? extends K, ? extends Integer> m) {
        this(m, DEFAULT_LOAD_FACTOR);
    }

    public MirrorSet(final MirrorSet<? extends K> a) {
        this(a.size(), a.f);
        ensureCapacity(a.size()); // The resulting map will be sized for
        System.arraycopy(a.key, 0, key, 0, a.key.length);
        System.arraycopy(a.value, 0, value, 0, a.value.length);
        order.addAll(a.order);
        containsNullKey = a.containsNullKey;
    }

    /**
     * Creates a new MirrorSet using the elements of an array.
     *
     * @param keyArray the array of keys of the new MirrorSet.
     * @param f the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final K[] keyArray, final float f) {
        this(keyArray.length, f);
        for (int i = 0; i < keyArray.length; i++)
            put(keyArray[i], i);
    }

    /**
     * Creates a new MirrorSet using the elements of an array.
     *
     * @param keyColl the collection of keys of the new MirrorSet.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final Collection<K> keyColl) {
        this(keyColl, DEFAULT_LOAD_FACTOR);
    }
    /**
     * Creates a new MirrorSet using the given collection of keys.
     *
     * @param keyColl the collection of keys of the new MirrorSet.
     * @param f the load factor.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final Collection<K> keyColl, final float f) {
        this(keyColl.size(), f);
        Iterator<K> ki = keyColl.iterator();
        int idx = 0;
        while (ki.hasNext())
        {
            put(ki.next(), idx++);
        }
    }

    /**
     * Creates a new MirrorSet with 0.5f as load factor using the elements of an array.
     *
     * @param keyArray the array of keys of the new MirrorSet.
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final K[] keyArray) {
        this(keyArray, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new MirrorSet.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public MirrorSet(final int expected, final float f, CrossHash.IHasher hasher) {
        if (f <= 0 || f > 1)
            throw new IllegalArgumentException("Load factor must be greater than 0 and smaller than or equal to 1");
        if (expected < 0) throw new IllegalArgumentException("The expected number of elements must be nonnegative");
        this.f = f;
        n = arraySize(expected, f);
        mask = n - 1;
        maxFill = maxFill(n, f);
        key = (K[]) new Object[n + 1];
        value = new int[n + 1];
        //link = new long[n + 1];
        order = new IntVLA(expected);
        this.hasher = (hasher == null) ? CrossHash.defaultHasher : hasher;
    }
    /**
     * Creates a new MirrorSet with 0.5f as load factor.
     *
     * @param expected the expected number of elements in the MirrorSet.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public MirrorSet(final int expected, CrossHash.IHasher hasher) {
        this(expected, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new MirrorSet with initial expected 16 entries and 0.5f as load factor.
     */
    public MirrorSet(CrossHash.IHasher hasher) {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new MirrorSet copying a given one.
     *
     * @param m a {@link Map} to be copied into the new MirrorSet.
     * @param f the load factor.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public MirrorSet(final Map<? extends K, ? extends Integer> m, final float f, CrossHash.IHasher hasher) {
        this(m.size(), f, hasher);
        putAll(m);
    }

    /**
     * Creates a new MirrorSet with 0.5f as load factor copying a given one.
     * @param m a {@link Map} to be copied into the new MirrorSet.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public MirrorSet(final Map<? extends K, ? extends Integer> m, CrossHash.IHasher hasher) {
        this(m, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new MirrorSet using the elements of two parallel arrays.
     *
     * @param keyArray the array of keys of the new MirrorSet.
     * @param f the load factor.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final K[] keyArray, final float f, CrossHash.IHasher hasher) {
        this(keyArray.length, f, hasher);

        for (int i = 0; i < keyArray.length; i++)
            put(keyArray[i], i);
    }
    /**
     * Creates a new MirrorSet with 0.5f as load factor using the elements of two parallel arrays.
     *
     * @param keyArray the array of keys of the new MirrorSet.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     * @throws IllegalArgumentException if <code>k</code> and <code>v</code> have different lengths.
     */
    public MirrorSet(final K[] keyArray, CrossHash.IHasher hasher) {
        this(keyArray, DEFAULT_LOAD_FACTOR, hasher);
    }

    private int realSize() {
        return containsNullKey ? size - 1 : size;
    }
    private void ensureCapacity(final int capacity) {
        final int needed = arraySize(capacity, f);
        if (needed > n)
            rehash(needed);
    }
    private void tryCapacity(final long capacity) {
        final int needed = (int) Math.min(
                1 << 30,
                Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(capacity
                        / f))));
        if (needed > n)
            rehash(needed);
    }
    private int removeEntry(final int pos) {
        size--;
        fixOrder(pos);
        shiftKeys(pos);
        final int oldValue = value[pos];
        fixValues(oldValue);
        if (size < (maxFill >>> 2) && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return oldValue;
    }
    private int removeNullEntry() {
        containsNullKey = false;
        key[n] = null;
        final int oldValue = value[n];
        size--;
        fixOrder(n);
        fixValues(oldValue);
        if (size < (maxFill >>> 2) && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return oldValue;
    }
    @Override
    public void putAll(Map<? extends K, ? extends Integer> m) {
        if (f <= .5)
            ensureCapacity(m.size()); // The resulting map will be sized for
            // m.size() elements
        else
            tryCapacity(size() + m.size()); // The resulting map will be
        int n = m.size(), idx = size;
        final Iterator<? extends K> i = m
                .keySet().iterator();
        while (n-- != 0) {
            put(i.next(), idx++);
        }
    }

    public void putAll(K[] keyArray) {
        if (f <= .5)
            ensureCapacity(keyArray.length); // The resulting map will be sized for
            // m.size() elements
        else
            tryCapacity(size() + keyArray.length); // The resulting map will be
        int n = keyArray.length;
        for (int i = 0; i < n; i++) {
            put(keyArray[i], i);
        }
    }

    public void putAll(Collection<? extends K> keyArray) {
        if (f <= .5)
            ensureCapacity(keyArray.size()); // The resulting map will be sized for
            // m.size() elements
        else
            tryCapacity(size() + keyArray.size()); // The resulting map will be
        int n = keyArray.size();
        Iterator<? extends K> it = keyArray.iterator();
        while (it.hasNext())
            put(it.next(), 0); // value arguments to put are disregarded
    }
    private int insert(final K k, final int v) {
        int pos;
        if (k == null) {
            if (containsNullKey)
                return n;
            containsNullKey = true;
            pos = n;
        } else {
            K curr;
            final K[] key = this.key;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) != null) {
                if (curr.equals(k)) {
                    return pos;
                }
                while ((curr = key[pos = (pos + 1) & mask]) != null)
                    if (curr.equals(k)) {
                        return pos;
                    }
            }
        }
        key[pos] = k;
        if (size == 0) {
            first = last = pos;
        } else {
            last = pos;
        }
        order.add(pos);
        value[pos] = size;
        if (size++ >= maxFill)
            rehash(arraySize(size + 1, f));
        return -1;
    }
    private int insertAt(final K k, final int at) {
        int pos;
        if (k == null) {
            if (containsNullKey)
                return n;
            containsNullKey = true;
            pos = n;
        } else {
            K curr;
            final K[] key = this.key;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) != null) {
                if (curr.equals(k)) {
                    order.removeIndex(value[pos]);
                    order.insert(at, pos);
                    return pos;
                }
                while ((curr = key[pos = (pos + 1) & mask]) != null)
                    if (curr.equals(k)) {
                        order.removeIndex(value[pos]);
                        order.insert(at, pos);
                        return pos;
                    }
            }
        }
        key[pos] = k;
        if (size == 0) {
            first = last = pos;
        } else {
            last = pos;
        }
        order.insert(at, pos);
        value[pos] = at;
        if (size++ >= maxFill)
            rehash(arraySize(size + 1, f));
        return -1;
    }

    /**
     * Puts the key k into this MirrorSet with a value equal to the current number of keys; v is disregarded.
     * @param k any K type, including null
     * @param v any Integer, doesn't matter what it is and will be disregarded. Only here for compatibility
     * @return the Integer that was previously associated with k, or -1 if there was none
     */
    @Deprecated
    public Integer put(final K k, final Integer v) {
        final int pos = insert(k, v);
        if (pos < 0)
            return defRetValue;
        final Integer oldValue = value[pos];
        value[pos] = size-1;
        return oldValue;
    }

    public int put(final K k, final int v) {
        final int pos = insert(k, v);
        if (pos < 0)
            return defRetValue;
        final int oldValue = value[pos];
        value[pos] = size-1;
        return oldValue;
    }

    public int add(final K k) {
        final int pos = insert(k, size);
        if (pos < 0)
            return defRetValue;
        final int oldValue = value[pos];
        value[pos] = size - 1;
        return oldValue;
    }

    protected void fixValues(int start)
    {
        for (int i = start; i < size; i++) {
            value[order.items[i]] = i;
        }
    }

    /**
     * Shifts left entries with the specified hash code, starting at the
     * specified position, and empties the resulting free entry.
     *
     * @param pos
     *            a starting position.
     */
    protected final void shiftKeys(int pos) {
        // Shift entries with the same hash.
        int last, slot;
        K curr;
        final K[] key = this.key;
        for (;;) {
            pos = ((last = pos) + 1) & mask;
            for (;;) {
                if ((curr = key[pos]) == null) {
                    key[last] = null;
                    return;
                }
                slot = HashCommon.mix(hasher.hash(curr))
                        & mask;
                if (last <= pos ? last >= slot || slot > pos : last >= slot
                        && slot > pos)
                    break;
                pos = (pos + 1) & mask;
            }
            key[last] = curr;
            fixOrder(pos, last);
        }
    }
    @SuppressWarnings("unchecked")
    public Integer remove(final Object k) {
        if ((K) k == null) {
            if (containsNullKey)
                return removeNullEntry();
            return null;
        }
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return null;
        if (k.equals(curr))
            return removeEntry(pos);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return null;
            if (k.equals(curr))
                return removeEntry(pos);
        }
    }
    @SuppressWarnings("unchecked")
    public int removeInt(final Object k) {
        if ((K) k == null) {
            if (containsNullKey)
                return removeNullEntry();
            return defRetValue;
        }
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return defRetValue;
        if (k.equals(curr))
            return removeEntry(pos);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return defRetValue;
            if (k.equals(curr))
                return removeEntry(pos);
        }
    }
    private int setValue(final int pos, final int v) {
        final int oldValue = value[pos];
        value[pos] = v;
        return oldValue;
    }
    /**
     * Removes the mapping associated with the first key in iteration order.
     *
     * @return the value previously associated with the first key in iteration
     *         order.
     * @throws NoSuchElementException
     *             is this map is empty.
     */
    public K removeFirst() {
        if (size == 0)
            throw new NoSuchElementException();
        final int pos = first;
        K fst = key[pos];
        order.removeIndex(0);
        if(order.size > 0)
            first = order.get(0);
        else
            first = -1;
        // Abbreviated version of fixOrder(pos)
        /*first = (int) link[pos];
        if (0 <= first) {
            // Special case of SET_PREV( link[ first ], -1 )
            link[first] |= (-1 & 0xFFFFFFFFL) << 32;
        }*/
        size--;
        final int v = value[pos];
        if (pos == n) {
            containsNullKey = false;
            key[n] = null;
        } else
            shiftKeys(pos);
        fixValues(v);
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return fst;
    }
    /**
     * Removes the mapping associated with the last key in iteration order.
     *
     * @return the value previously associated with the last key in iteration
     *         order.
     * @throws NoSuchElementException
     *             is this map is empty.
     */
    public K removeLast() {
        if (size == 0)
            throw new NoSuchElementException();
        final int pos = last;
        K lst = key[pos];
        order.pop();
        if(order.size > 0)
            last = order.get(order.size - 1);
        else
            last = -1;

        // Abbreviated version of fixOrder(pos)
        /*
        last = (int) (link[pos] >>> 32);
        if (0 <= last) {
            // Special case of SET_NEXT( link[ last ], -1 )
            link[last] |= -1 & 0xFFFFFFFFL;
        }*/
        size--;
        if (pos == n) {
            containsNullKey = false;
            key[n] = null;
        } else
            shiftKeys(pos);
        //fixValues(v); // one case where we don't need to do this; the last item is just given -1
        value[pos] = -1;
        if (size < maxFill / 4 && n > DEFAULT_INITIAL_SIZE)
            rehash(n / 2);
        return lst;
    }
    private void moveIndexToFirst(final int i) {
        if(size <= 1 || first == i)
            return;
        order.moveToFirst(i);
        if (last == i) {
            last = order.peek();
            //last = (int) (link[i] >>> 32);
            // Special case of SET_NEXT( link[ last ], -1 );
            //link[last] |= -1 & 0xFFFFFFFFL;
        }/* else {
            final long linki = link[i];
            final int prev = (int) (linki >>> 32);
            final int next = (int) linki;
            link[prev] ^= ((link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
            link[next] ^= ((link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L);
        }
        link[first] ^= ((link[first] ^ ((i & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L);
        link[i] = ((-1 & 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
        */
        first = i;
        fixValues(0);
    }
    private void moveIndexToLast(final int i) {
        if(size <= 1 || last == i)
            return;
        order.moveToLast(i);
        if (first == i) {
            first = order.get(0);
            //first = (int) link[i];
            // Special case of SET_PREV( link[ first ], -1 );
            //link[first] |= (-1 & 0xFFFFFFFFL) << 32;
        } /*else {
            final long linki = link[i];
            final int prev = (int) (linki >>> 32);
            final int next = (int) linki;
            link[prev] ^= ((link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
            link[next] ^= ((link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L);
        }
        link[last] ^= ((link[last] ^ (i & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
        link[i] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
        */
        last = i;
        fixValues(i);
    }
    /**
     * Returns the value to which the given key is mapped; if the key is
     * present, it is moved to the first position of the iteration order.
     *
     * @param k
     *            the key.
     * @return the corresponding value, or -1 if no value was present for the given key.
     */
    public int getAndMoveToFirst(final K k) {
        if (k == null) {
            if (containsNullKey) {
                moveIndexToFirst(n);
                return value[n];
            }
            return defRetValue;
        }
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return defRetValue;
        if (k.equals(curr)) {
            moveIndexToFirst(pos);
            return value[pos];
        }
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return defRetValue;
            if (k.equals(curr)) {
                moveIndexToFirst(pos);
                return value[pos];
            }
        }
    }
    /**
     * Returns the value to which the given key is mapped; if the key is
     * present, it is moved to the last position of the iteration order.
     *
     * @param k
     *            the key.
     * @return the corresponding value, or -1 if no value was present for the given key.
     */
    public int getAndMoveToLast(final K k) {
        if (k == null) {
            if (containsNullKey) {
                moveIndexToLast(n);
                return value[n];
            }
            return defRetValue;
        }
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return defRetValue;
        if (k.equals(curr)) {
            moveIndexToLast(pos);
            return value[pos];
        }
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return defRetValue;
            if (k.equals(curr)) {
                moveIndexToLast(pos);
                return value[pos];
            }
        }
    }
    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * first position of the iteration order.
     *
     * @param k
     *            the key.
     * @param v
     *            the value.
     * @return the old value, or -1 if no value was present for the given key.
     */
    public int putAndMoveToFirst(final K k, final int v) {
        int pos;
        if (k == null) {
            if (containsNullKey) {
                moveIndexToFirst(n);
                return setValue(n, 0);
            }
            containsNullKey = true;
            pos = n;
        } else {
            K curr;
            final K[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)) {
                if (curr.equals(k)) {
                    moveIndexToFirst(pos);
                    return setValue(pos, 0);
                }
                while (!((curr = key[pos = (pos + 1) & mask]) == null))
                    if (curr.equals(k)) {
                        moveIndexToFirst(pos);
                        return setValue(pos, 0);
                    }
            }
        }
        key[pos] = k;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            //link[pos] = -1L;
        } else {
            //link[first] ^= ((link[first] ^ ((pos & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L);
            //link[pos] = ((-1 & 0xFFFFFFFFL) << 32) | (first & 0xFFFFFFFFL);
            first = pos;
        }
        order.insert(0, pos);
        fixValues(0);
        if (size++ >= maxFill)
            rehash(arraySize(size, f));
        return defRetValue;
    }
    /**
     * Adds a pair to the map; if the key is already present, it is moved to the
     * last position of the iteration order.
     *
     * @param k
     *            the key.
     * @param v
     *            the value.
     * @return the old value, or -1 if no value was present for the given key.
     */
    public int putAndMoveToLast(final K k, final int v) {
        int pos;
        if (k == null) {
            if (containsNullKey) {
                moveIndexToLast(n);
                return setValue(n, size - 1);
            }
            containsNullKey = true;
            pos = n;
        } else {
            K curr;
            final K[] key = this.key;
            // The starting point.
            if (!((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)) {
                if (curr.equals(k)) {
                    moveIndexToLast(pos);
                    return setValue(pos, size - 1);
                }
                while (!((curr = key[pos = (pos + 1) & mask]) == null))
                    if (curr.equals(k)) {
                        moveIndexToLast(pos);
                        return setValue(pos, size - 1);
                    }
            }
        }
        key[pos] = k;
        value[pos] = size;
        if (size == 0) {
            first = last = pos;
            // Special case of SET_UPPER_LOWER( link[ pos ], -1, -1 );
            //link[pos] = -1L;
        } else {
            //link[last] ^= ((link[last] ^ (pos & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
            //link[pos] = ((last & 0xFFFFFFFFL) << 32) | (-1 & 0xFFFFFFFFL);
            last = pos;
        }
        order.add(pos);
        if (size++ >= maxFill)
            rehash(arraySize(size, f));
        return defRetValue;
    }
    public Integer get(final Object k) {
        if (k == null)
            return containsNullKey ? value[n] : defRetValue;
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return defRetValue;
        if (k.equals(curr))
            return value[pos];
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return defRetValue;
            if (k.equals(curr))
                return value[pos];
        }
    }
    public int getInt(final Object k) {
        if (k == null)
            return containsNullKey ? value[n] : defRetValue;
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return defRetValue;
        if (k.equals(curr))
            return value[pos];
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return defRetValue;
            if (k.equals(curr))
                return value[pos];
        }
    }

    public boolean containsKey(final Object k) {
        if (k == null)
            return containsNullKey;
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
            return false;
        if (k.equals(curr))
            return true;
        // There's always an unused entry.
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return false;
            if (k.equals(curr))
                return true;
        }
    }
    public boolean containsValue(final int v) {
        return v >= 0 && v < size;
    }
    @Override
    public boolean containsValue(final Object ov) {
        return ov != null && containsValue(((Integer) ov).intValue());
    }
    /*
     * Removes all elements from this map.
     *
     * <P>To increase object reuse, this method does not change the table size.
     * If you want to reduce the table size, you must use {@link #trim()}.
     */
    public void clear() {
        if (size == 0)
            return;
        size = 0;
        containsNullKey = false;
        Arrays.fill(key, null);
        Arrays.fill(value, -1);
        first = last = -1;
        order.clear();
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    @Override
    public Iterator<K> iterator() {
        return new KeyIterator();
    }

    /**
     * The entry class for a hash map does not record key and value, but rather
     * the position in the hash table of the corresponding entry. This is
     * necessary so that calls to {@link Entry#setValue(Object)}
     * are reflected in the map
     */
    final class MapEntry
            implements
            Entry<K, Integer> {
        // The table index this entry refers to, or -1 if this entry has been
        // deleted.
        int index;
        MapEntry(final int index) {
            this.index = index;
        }
        MapEntry() {
        }
        public K getKey() {
            return key[index];
        }
        /**
         * {@inheritDoc}
         *
         * @deprecated Please use the corresponding type-specific method
         *             instead.
         */
        @Deprecated
        public Integer getValue() {
            return value[index];
        }
        public int getIntValue() {
            return value[index];
        }
        public int setValue(final int v) {
            final int oldValue = value[index];
            value[index] = v;
            return oldValue;
        }
        public Integer setValue(final Integer v) {
            return setValue(v.intValue());
        }

        @SuppressWarnings("unchecked")
        public boolean equals(final Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Entry<K, Integer> e = (Entry<K, Integer>) o;
            return (key[index] == null
                    ? e.getKey() == null
                    : key[index].equals(e.getKey()))
                    && (value[index] == e.getValue());
        }
        public int hashCode() {
            return (key[index] == null ? 0 : hasher.hash(key[index]))
                    ^ value[index];
        }
        public String toString() {
            return key[index] + "=>" + value[index];
        }
    }

    /**
     * Modifies the link vector so that the given entry is removed. This method will complete in logarithmic time.
     *
     * @param i the index of an entry.
     */
    protected void fixOrder(final int i) {
        if (size == 0) {
            first = last = -1;
            return;
        }
        order.removeValue(i);
        if (first == i) {
            first = order.get(0);
            //first = (int) link[i];
            /*
            if (0 <= first) {
                // Special case of SET_PREV( link[ first ], -1 )
                link[first] |= (-1 & 0xFFFFFFFFL) << 32;
            }
            return;
            */
        }
        if (last == i) {
            last = order.peek();
            //last = (int) (link[i] >>> 32);
            /*if (0 <= last) {
                // Special case of SET_NEXT( link[ last ], -1 )
                link[last] |= -1 & 0xFFFFFFFFL;
            }
            return;
            */
        }
        /*
        final long linki = link[i];
        final int prev = (int) (linki >>> 32);
        final int next = (int) linki;
        link[prev] ^= ((link[prev] ^ (linki & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
        link[next] ^= ((link[next] ^ (linki & 0xFFFFFFFF00000000L)) & 0xFFFFFFFF00000000L);
        */
    }

    /**
     * Modifies the link vector for a shift from s to d.
     * <br>
     * This method will complete in logarithmic time or better.
     *
     * @param s the source position.
     * @param d the destination position.
     */
    protected void fixOrder(int s, int d) {
        if (size == 1) {
            first = last = d;
            // Special case of SET_UPPER_LOWER( link[ d ], -1, -1 )
            //link[d] = -1L;
            order.set(0, d);
        }
        else if (first == s) {
            first = d;
            order.set(0, d);
            //link[(int) link[s]] ^= ((link[(int) link[s]] ^ ((d & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L);
            //link[d] = link[s];
        }
        else if (last == s) {
            last = d;
            order.set(order.size - 1, d);
            //link[(int) (link[s] >>> 32)] ^= ((link[(int) (link[s] >>> 32)] ^ (d & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
            //link[d] = link[s];
        }
        else
        {
            order.set(order.indexOf(s), d);
        }
        /*
        final long links = link[s];
        final int prev = (int) (links >>> 32);
        final int next = (int) links;
        link[prev] ^= ((link[prev] ^ (d & 0xFFFFFFFFL)) & 0xFFFFFFFFL);
        link[next] ^= ((link[next] ^ ((d & 0xFFFFFFFFL) << 32)) & 0xFFFFFFFF00000000L);
        link[d] = links;
        */
    }

    /**
     * Returns the first key of this map in iteration order.
     *
     * @return the first key in iteration order.
     */
    public K firstKey() {
        if (size == 0)
            throw new NoSuchElementException();
        return key[first];
    }
    /**
     * Returns the last key of this map in iteration order.
     *
     * @return the last key in iteration order.
     */
    public K lastKey() {
        if (size == 0)
            throw new NoSuchElementException();
        return key[last];
    }
    /**
     * Retains in this collection only elements from the given collection.
     *
     * @param c a collection.
     * @return <code>true</code> if this collection changed as a result of the
     * call.
     */
    public boolean retainAll(Collection<?> c) {
        boolean retVal = false;
        int n = size;
        while (n-- != 0) {
            if (!c.contains(key[order.get(n)])) {
                removeAt(n);
                retVal = true;
            }
        }
        return retVal;
    }

    public Comparator<? super K> comparator() {
        return null;
    }
    public SortedMap<K, Integer> tailMap(K from) {
        throw new UnsupportedOperationException();
    }
    public SortedMap<K, Integer> headMap(K to) {
        throw new UnsupportedOperationException();
    }
    public SortedMap<K, Integer> subMap(K from, K to) {
        throw new UnsupportedOperationException();
    }
    /**
     * A list iterator over a MirrorSet.
     *
     * <P>
     * This class provides a list iterator over a MirrorSet. The
     * constructor runs in constant time.
     */
    private class MapIterator {
        /**
         * The entry that will be returned by the next call to
         * {@link ListIterator#previous()} (or <code>null</code> if no
         * previous entry exists).
         */
        int prev = -1;
        /**
         * The entry that will be returned by the next call to
         * {@link ListIterator#next()} (or <code>null</code> if no
         * next entry exists).
         */
        int next = -1;
        /**
         * The last entry that was returned (or -1 if we did not iterate or used
         * {@link Iterator#remove()}).
         */
        int curr = -1;
        /**
         * The current index (in the sense of a {@link ListIterator}).
         * Note that this value is not meaningful when this iterator has been
         * created using the nonempty constructor.
         */
        int index = 0;
        private MapIterator() {
            next = first;
            index = 0;
        }
        /*
        private MapIterator(final K from) {
            if (((from) == null)) {
                if (containsNullKey) {
                    next = (int) link[n];
                    prev = n;
                    return;
                } else
                    throw new NoSuchElementException("The key null"
                            + " does not belong to this map.");
            }
            if (((key[last]) != null && (key[last]).equals(from))) {
                prev = last;
                index = size;
                return;
            }
            // The starting point.
            int pos = (HashCommon.mix((from).hashCode()))
                    & mask;
            // There's always an unused entry.
            while (!((key[pos]) == null)) {
                if (((key[pos]).equals(from))) {
                    // Note: no valid index known.
                    next = (int) link[pos];
                    prev = pos;
                    return;
                }
                pos = (pos + 1) & mask;
            }
            throw new NoSuchElementException("The key " + from
                    + " does not belong to this map.");
        }*/
        public boolean hasNext() {
            return next != -1;
        }
        public boolean hasPrevious() {
            return prev != -1;
        }
        private void ensureIndexKnown() {
            if (index >= 0)
                return;
            if (prev == -1) {
                index = 0;
                return;
            }
            if (next == -1) {
                index = size;
                return;
            }
            index = 0;
            /*while (pos != prev) {
                pos = (int) link[pos];
                index++;
            }*/
        }
        public int nextIndex() {
            ensureIndexKnown();
            return index + 1;
        }
        public int previousIndex() {
            ensureIndexKnown();
            return index - 1;
        }
        public int nextEntry() {
            if (!hasNext())
                throw new NoSuchElementException();
            curr = next;
            if(++index >= order.size)
                next = -1;
            else
                next = order.get(index);//(int) link[curr];
            prev = curr;
            return curr;
        }
        public int previousEntry() {
            if (!hasPrevious())
                throw new NoSuchElementException();
            curr = prev;
            if(--index < 1)
                prev = -1;
            else
                prev = order.get(index - 1);
            //prev = (int) (link[curr] >>> 32);
            next = curr;
            return curr;
        }
        public void remove() {
            ensureIndexKnown();
            if (curr == -1)
                throw new IllegalStateException();
            if (curr == prev) {
				/*
				 * If the last operation was a next(), we are removing an entry
				 * that precedes the current index, and thus we must decrement
				 * it.
				 */
                if(--index >= 1)
                    prev = order.get(index - 1); //(int) (link[curr] >>> 32);
                else
                    prev = -1;
            } else {
                if(index < order.size - 1)
                    next = order.get(index + 1);
                else
                    next = -1;
            }
            /*
			 * Now we manually fix the pointers. Because of our knowledge of
			 * next and prev, this is going to be faster than calling
			 * fixOrder().
			 */
            if (prev == -1)
                first = next;
            if (next == -1)
                last = prev;
            order.removeIndex(index);
            size--;
            int last, slot, pos = curr;
            curr = -1;
            if (pos == n) {
                containsNullKey = false;
                key[n] = null;
            } else {
                K curr;
                final K[] key = MirrorSet.this.key;
                // We have to horribly duplicate the shiftKeys() code because we
                // need to update next/prev.
                for (;;) {
                    pos = ((last = pos) + 1) & mask;
                    for (;;) {
                        if ((curr = key[pos]) == null) {
                            key[last] = null;
                            fixValues(index);
                            return;
                        }
                        slot = HashCommon.mix(hasher.hash(curr)) & mask;
                        if (last <= pos
                                ? last >= slot || slot > pos
                                : last >= slot && slot > pos)
                            break;
                        pos = (pos + 1) & mask;
                    }
                    key[last] = curr;
                    if (next == pos)
                        next = last;
                    if (prev == pos)
                        prev = last;
                    fixOrder(pos, last);
                }
            }
        }
        public int skip(final int n) {
            int i = n;
            while (i-- != 0 && hasNext())
                nextEntry();
            return n - i - 1;
        }
        public int back(final int n) {
            int i = n;
            while (i-- != 0 && hasPrevious())
                previousEntry();
            return n - i - 1;
        }
    }
    private class EntryIterator extends MapIterator
            implements
            Iterator<Entry<K, Integer>>, Serializable {
        private static final long serialVersionUID = 0L;

        private MapEntry entry;
        public EntryIterator() {
        }
        public MapEntry next() {
            return entry = new MapEntry(nextEntry());
        }
        public MapEntry previous() {
            return entry = new MapEntry(previousEntry());
        }
        @Override
        public void remove() {
            super.remove();
            entry.index = -1; // You cannot use a deleted entry.
        }
        public void set(Entry<K, Integer> ok) {
            throw new UnsupportedOperationException();
        }
        public void add(Entry<K, Integer> ok) {
            throw new UnsupportedOperationException();
        }
    }

    public class FastEntryIterator extends MapIterator implements ListIterator<MapEntry>, Serializable {
        private static final long serialVersionUID = 0L;

        final MapEntry entry = new MapEntry();

        public FastEntryIterator() {
        }
        public MapEntry next() {
            entry.index = nextEntry();
            return entry;
        }
        public MapEntry previous() {
            entry.index = previousEntry();
            return entry;
        }
        public void set(MapEntry ok) {
            throw new UnsupportedOperationException();
        }
        public void add(MapEntry ok) {
            throw new UnsupportedOperationException();
        }
    }
    private final class MapEntrySet
            implements Cloneable, SortedSet<Entry<K, Integer>>, Set<Entry<K, Integer>>, Collection<Entry<K, Integer>>, Serializable {
        private static final long serialVersionUID = 0L;
        public EntryIterator iterator() {
            return new EntryIterator();
        }
        public Comparator<? super Entry<K, Integer>> comparator() {
            return null;
        }
        public SortedSet<Entry<K, Integer>> subSet(
                Entry<K, Integer> fromElement,
                Entry<K, Integer> toElement) {
            throw new UnsupportedOperationException();
        }
        public SortedSet<Entry<K, Integer>> headSet(
                Entry<K, Integer> toElement) {
            throw new UnsupportedOperationException();
        }
        public SortedSet<Entry<K, Integer>> tailSet(
                Entry<K, Integer> fromElement) {
            throw new UnsupportedOperationException();
        }
        public Entry<K, Integer> first() {
            if (size == 0)
                throw new NoSuchElementException();
            return new MapEntry(MirrorSet.this.first);
        }
        public Entry<K, Integer> last() {
            if (size == 0)
                throw new NoSuchElementException();
            return new MapEntry(MirrorSet.this.last);
        }
        @SuppressWarnings("unchecked")
        public boolean contains(final Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            final Entry<?, ?> e = (Entry<?, ?>) o;
            final K k = (K) e.getKey();
            final int v = (Integer) e.getValue();
            if (k == null)
                return containsNullKey
                        && (value[n] == v);
            K curr;
            final K[] key = MirrorSet.this.key;
            int pos;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
                return false;
            if (k.equals(curr))
                return value[pos] == v;
            // There's always an unused entry.
            while (true) {
                if ((curr = key[pos = (pos + 1) & mask]) == null)
                    return false;
                if (k.equals(curr))
                    return value[pos] == v;
            }
        }
        @SuppressWarnings("unchecked")
        public boolean remove(final Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            final Entry<?, ?> e = (Entry<?, ?>) o;
            final K k = (K) e.getKey();
            final int v = (Integer) e.getValue();
            if (k == null) {
                if (containsNullKey
                        && value[n] == v) {
                    removeNullEntry();
                    return true;
                }
                return false;
            }
            K curr;
            final K[] key = MirrorSet.this.key;
            int pos;
            // The starting point.
            if ((curr = key[pos = HashCommon.mix(hasher.hash(k)) & mask]) == null)
                return false;
            if (curr.equals(k)) {
                if (value[pos] == v) {
                    removeEntry(pos);
                    return true;
                }
                return false;
            }
            while (true) {
                if ((curr = key[pos = (pos + 1) & mask]) == null)
                    return false;
                if (curr.equals(k)) {
                    if (value[pos] == v) {
                        removeEntry(pos);
                        return true;
                    }
                }
            }
        }
        public int size() {
            return size;
        }
        public void clear() {
            MirrorSet.this.clear();
        }

        public FastEntryIterator fastIterator() {
            return new FastEntryIterator();
        }

        @Override
        public boolean equals(final Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Set))
                return false;
            Set<?> s = (Set<?>) o;
            return s.size() == size() && containsAll(s);
        }

        public Object[] toArray() {
            final Object[] a = new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        @SuppressWarnings("unchecked")
        public <T> T[] toArray(T[] a) {
            if (a == null || a.length < size()) a = (T[]) new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        /**
         * Unsupported.
         *
         * @param c ignored
         * @return nothing, throws UnsupportedOperationException
         * @throws UnsupportedOperationException always
         */
        public boolean addAll(Collection<? extends Entry<K, Integer>> c) {
            throw new UnsupportedOperationException("addAll not supported");
        }

        /**
         * Unsupported.
         *
         * @param k ignored
         * @return nothing, throws UnsupportedOperationException
         * @throws UnsupportedOperationException always
         */
        public boolean add(Entry<K, Integer> k) {
            throw new UnsupportedOperationException("add not supported");
        }

        /**
         * Checks whether this collection contains all elements from the given
         * collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection contains all elements of the
         * argument.
         */
        public boolean containsAll(Collection<?> c) {
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (!contains(i.next()))
                    return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given collection.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the
         * call.
         */
        public boolean retainAll(Collection<?> c) {
            boolean retVal = false;
            int n = size();
            final Iterator<?> i = iterator();
            while (n-- != 0) {
                if (!c.contains(i.next())) {
                    i.remove();
                    retVal = true;
                }
            }
            return retVal;
        }

        /**
         * Remove from this collection all elements in the given collection. If the
         * collection is an instance of this class, it uses faster iterators.
         *
         * @param c a collection.
         * @return <code>true</code> if this collection changed as a result of the
         * call.
         */
        public boolean removeAll(Collection<?> c) {
            boolean retVal = false;
            int n = c.size();
            final Iterator<?> i = c.iterator();
            while (n-- != 0)
                if (remove(i.next()))
                    retVal = true;
            return retVal;
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        @Override
        public String toString() {
            final StringBuilder s = new StringBuilder();
            final EntryIterator i = iterator();
            int n = size();
            Object k;
            boolean first = true;
            s.append("{");
            while (n-- != 0) {
                if (first)
                    first = false;
                else
                    s.append(", ");
                k = i.next();
                if (this == k)
                    s.append("(this collection)");
                else
                    s.append(String.valueOf(k));
            }
            s.append("}");
            return s.toString();
        }

    }

    @Override
    public SortedSet<Entry<K, Integer>> entrySet() {
        if (entries == null) entries = new MapEntrySet();
        return entries;
    }
    public MapEntrySet mapEntrySet() {
        if (entries == null) entries = new MapEntrySet();
        return entries;
    }

    /**
     * An iterator on keys.
     * <p>
     * <P>We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return keys
     * instead of entries.
     */
    public final class KeyIterator extends MapIterator implements Iterator<K>, Serializable {
        private static final long serialVersionUID = 0L;
        public K previous() {
            return key[previousEntry()];
        }
        public void set(K k) {
            throw new UnsupportedOperationException();
        }
        public void add(K k) {
            throw new UnsupportedOperationException();
        }
        public KeyIterator() {}
        public K next() {
            return key[nextEntry()];
        }
        public void remove() { super.remove(); }
    }

    public final class KeySet implements SortedSet<K>, Serializable {
        private static final long serialVersionUID = 0L;

        public KeyIterator iterator() {
            return new KeyIterator();
        }

        public int size() {
            return size;
        }

        public void clear() {
            MirrorSet.this.clear();
        }

        public K first() {
            if (size == 0) throw new NoSuchElementException();
            return key[first];
        }

        public K last() {
            if (size == 0) throw new NoSuchElementException();
            return key[last];
        }

        public Comparator<K> comparator() {
            return null;
        }

        public final SortedSet<K> tailSet(K from) {
            throw new UnsupportedOperationException();
        }

        public final SortedSet<K> headSet(K to) {
            throw new UnsupportedOperationException();
        }

        public final SortedSet<K> subSet(K from, K to) {
            throw new UnsupportedOperationException();
        }

        @SuppressWarnings("unchecked")
        @Override
        public <T> T[] toArray(T[] a) {
            if (a == null || a.length < size()) a = (T[]) new Object[size()];
            unwrap(iterator(), a);
            return a;
        }

        /**
         * Always throws an UnsupportedOperationException
         */
        public boolean remove(Object ok) {
            throw new UnsupportedOperationException("Cannot remove from the key set directly");
        }

        /**
         * Always throws an UnsupportedOperationException
         */
        public boolean add(final K o) {
            throw new UnsupportedOperationException("Cannot add to the key set directly");
        }

        /**
         * Delegates to the corresponding type-specific method.
         */
        public boolean contains(final Object o) {
            return containsKey(o);
        }

        /**
         * Checks whether this collection contains all elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection contains all elements of the argument.
         */
        public boolean containsAll(Collection<?> c) {
            final Iterator<?> i = c.iterator();
            int n = c.size();
            while (n-- != 0)
                if (!contains(i.next())) return false;
            return true;
        }

        /**
         * Retains in this collection only elements from the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean retainAll(Collection<?> c) {
            throw new UnsupportedOperationException("Cannot remove from the key set directly");
        }

        /**
         * Remove from this collection all elements in the given type-specific collection.
         *
         * @param c a type-specific collection.
         * @return <code>true</code> if this collection changed as a result of the call.
         */
        public boolean removeAll(Collection<?> c) {
            throw new UnsupportedOperationException("Cannot remove from the key set directly");
        }

        public Object[] toArray() {
            final Object[] a = new Object[size()];
            objectUnwrap(iterator(), a);
            return a;
        }

        /**
         * Always throws an UnsupportedOperationException.
         * @param c disregarded; always throws Exception
         * @return nothing; always throws Exception
         */
        public boolean addAll(Collection<? extends K> c) {
            throw new UnsupportedOperationException("Cannot add to the key set directly");
        }

        @Override
        public boolean equals(final Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Set))
                return false;
            Set<?> s = (Set<?>) o;
            if (s.size() != size())
                return false;
            return containsAll(s);
        }
        /**
         * Unwraps an iterator into an array starting at a given offset for a given number of elements.
         * <p>
         * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
         * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
         *
         * @param i      a type-specific iterator.
         * @param array  an array to contain the output of the iterator.
         * @param offset the first element of the array to be returned.
         * @param max    the maximum number of elements to unwrap.
         * @return the number of elements unwrapped.
         */
        public int unwrap(final KeyIterator i, final Object[] array, int offset, final int max) {
            if (max < 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
            if (offset < 0 || offset + max > array.length) throw new IllegalArgumentException();
            int j = max;
            while (j-- != 0 && i.hasNext())
                array[offset++] = i.next();
            return max - j - 1;
        }

        /**
         * Unwraps an iterator into an array.
         * <p>
         * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
         * of the array has been reached.
         *
         * @param i     a type-specific iterator.
         * @param array an array to contain the output of the iterator.
         * @return the number of elements unwrapped.
         */
        public int unwrap(final KeyIterator i, final Object[] array) {
            return unwrap(i, array, 0, array.length);
        }

        public boolean isEmpty() {
            return size() == 0;
        }

        @Override
        public String toString() {
            final StringBuilder s = new StringBuilder();
            final KeyIterator i = iterator();
            int n = size();
            boolean first = true;
            s.append("{");
            while (n-- != 0) {
                if (first) first = false;
                else s.append(", ");
                s.append(i.next());
            }
            s.append("}");
            return s.toString();
        }
    }

    public KeySet keySet() {
        if (keys == null) keys = new KeySet();
        return keys;
    }

    public OrderedSet<K> keysAsOrderedSet()
    {
        OrderedSet<K> os = new OrderedSet<K>(size, f, hasher);
        for (int i = 0; i < size; i++) {
            os.add(keyAt(i));
        }
        return os;
    }

    /**
     * An iterator on values.
     * <p>
     * <P>We simply override the {@link ListIterator#next()}/{@link ListIterator#previous()} methods (and possibly their type-specific counterparts) so that they return values
     * instead of entries.
     */
    public final class ValueIterator extends MapIterator implements ListIterator<Integer>, Serializable {
        private static final long serialVersionUID = 0L;

        public Integer previous() {
            return (index < 0) ? -1 : --index;
        }
        public int previousInt() {
            return (index < 0) ? -1 : --index;
        }
        public void set(Integer v) {
            throw new UnsupportedOperationException();
        }
        public void add(Integer v) {
            throw new UnsupportedOperationException();
        }
        public ValueIterator() {}
        public Integer next() {
            return (index >= size - 1) ? -1 : ++index;
        }public int nextInt() {
            return (index >= size - 1) ? -1 : ++index;
        }
        public void remove() { super.remove(); }
    }
    public final class ValueCollection extends AbstractCollection<Integer> implements Serializable
    {
        private static final long serialVersionUID = 0L;
        public ValueIterator iterator() {
            return new ValueIterator();
        }
        public int size() {
            return size;
        }
        public boolean contains(Object v) {
            return containsValue(v);
        }
        public void clear() {
            MirrorSet.this.clear();
        }
    }
    public Collection<Integer> values() {
        if (values == null) values = new ValueCollection();
        return values;
    }

    public ArrayList<Integer> valuesAsList()
    {
        ArrayList<Integer> ls = new ArrayList<>(size);
        for (int i = 0; i < size; i++) {
            ls.add(i);
        }
        return ls;
    }

    public IntVLA valuesAsIntVLA()
    {
        return new IntVLA(ArrayTools.range(size));
    }
    public int[] valuesAsArray()
    {
        return ArrayTools.range(size);
    }

    /**
     * Rehashes the map, making the table as small as possible.
     * <p>
     * <P>This method rehashes the table to the smallest size satisfying the load factor. It can be used when the set will not be changed anymore, so to optimize access speed and size.
     * <p>
     * <P>If the table size is already the minimum possible, this method does nothing.
     *
     * @return true if there was enough memory to trim the map.
     * @see #trim(int)
     */
    public boolean trim() {
        final int l = arraySize(size, f);
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes this map if the table is too large.
     * <p>
     * <P>Let <var>N</var> be the smallest table size that can hold <code>max(n,{@link #size()})</code> entries, still satisfying the load factor. If the current table size is smaller than or equal to
     * <var>N</var>, this method does nothing. Otherwise, it rehashes this map in a table of size <var>N</var>.
     * <p>
     * <P>This method is useful when reusing maps. {@linkplain #clear() Clearing a map} leaves the table size untouched. If you are reusing a map many times, you can call this method with a typical
     * size to avoid keeping around a very large table just because of a few large transient maps.
     *
     * @param n the threshold for the trimming.
     * @return true if there was enough memory to trim the map.
     * @see #trim()
     */
    public boolean trim(final int n) {
        final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / f));
        if (l >= n || size > maxFill(l, f)) return true;
        try {
            rehash(l);
        } catch (Exception cantDoIt) {
            return false;
        }
        return true;
    }

    /**
     * Rehashes the map.
     *
     * <P>
     * This method implements the basic rehashing strategy, and may be overriden
     * by subclasses implementing different rehashing strategies (e.g.,
     * disk-based rehashing). However, you should not override this method
     * unless you understand the internal workings of this class.
     *
     * @param newN
     *            the new size
     */

    @SuppressWarnings("unchecked")
    protected void rehash(final int newN) {
        final K key[] = this.key;
        final int[] value = this.value;
        final int mask = newN - 1; // Note that this is used by the hashing macro
        final K newKey[] = (K[]) new Object[newN + 1];
        final int[] newValue = new int[newN + 1];
        int i, pos, sz = order.size, originalFirst = first, originalLast = last;
        for (int q = 0; q < sz; q++) {
            i = order.get(q);
            if (key[i] == null)
                pos = newN;
            else {
                pos = HashCommon.mix(hasher.hash(key[i])) & mask;
                while (!(newKey[pos] == null))
                    pos = (pos + 1) & mask;
            }
            newKey[pos] = key[i];
            newValue[pos] = value[i];
            order.set(q, pos);
            if(i == originalFirst)
                first = pos;
            if(i == originalLast)
                last = pos;
        }
        n = newN;
        this.mask = mask;
        maxFill = maxFill(n, f);
        this.key = newKey;
        this.value = newValue;
    }
    /**
     * Returns a deep copy of this map.
     *
     * <P>
     * This method performs a deep copy of this MirrorSet; the data stored in the
     * map, however, is not cloned. Note that this makes a difference only for
     * object keys.
     *
     * @return a deep copy of this map.
     */
    @SuppressWarnings("unchecked")
    @GwtIncompatible
    public MirrorSet<K> clone() {
        MirrorSet<K> c;
        try {
            c = (MirrorSet<K>) super.clone();
            c.key = (K[]) new Object[n + 1];
            System.arraycopy(key, 0, c.key, 0, n + 1);
            c.value = new int[n + 1];
            System.arraycopy(value, 0, c.value, 0, n + 1);
            c.order = (IntVLA) order.clone();
            c.hasher = hasher;
            return c;
        } catch (Exception cantHappen) {
            throw new UnsupportedOperationException(cantHappen + (cantHappen.getMessage() != null ?
                    "; " + cantHappen.getMessage() : ""));
        }
    }
    /**
     * Returns a hash code for this map.
     *
     * This method overrides the generic method provided by the superclass.
     * Since <code>equals()</code> is not overriden, it is important that the
     * value returned by this method is the same value as the one returned by
     * the overriden method.
     *
     * @return a hash code for this map.
     */
    public int hashCode() {
        int h = 0;
        for (int j = realSize(), i = 0, t = 0; j-- != 0;) {
            while (key[i] == null)
                i++;
            if (this != key[i])
                t = hasher.hash(key[i]);
            t ^= value[i];
            h += t;
            i++;
        }
        // Zero / null keys have hash zero.
        if (containsNullKey)
            h += value[n];
        return h;
    }
    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static int maxFill(final int n, final float f) {
        /* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((int) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the maximum number of entries that can be filled before rehashing.
     *
     * @param n the size of the backing array.
     * @param f the load factor.
     * @return the maximum number of entries before rehashing.
     */
    public static long maxFill(final long n, final float f) {
		/* We must guarantee that there is always at least
		 * one free entry (even with pathological load factors). */
        return Math.min((long) Math.ceil(n * f), n - 1);
    }

    /**
     * Returns the least power of two smaller than or equal to 2<sup>30</sup> and larger than or equal to <code>Math.ceil( expected / f )</code>.
     *
     * @param expected the expected number of elements in a hash table.
     * @param f        the load factor.
     * @return the minimum possible size for a backing array.
     * @throws IllegalArgumentException if the necessary size is larger than 2<sup>30</sup>.
     */
    public static int arraySize(final int expected, final float f) {
        final long s = Math.max(2, HashCommon.nextPowerOfTwo((long) Math.ceil(expected / f)));
        if (s > (1 << 30))
            throw new IllegalArgumentException("Too large (" + expected + " expected elements with load factor " + f + ")");
        return (int) s;
    }

    private static class HashCommon {

        private HashCommon() {
        }

        ;

        /**
         * This reference is used to fill keys and values of removed entries (if
         * they are objects). <code>null</code> cannot be used as it would confuse the
         * search algorithm in the presence of an actual <code>null</code> key.
         */
        public static final Object REMOVED = new Object();

        /**
         * 2<sup>32</sup> &middot; &phi;, &phi; = (&#x221A;5 &minus; 1)/2.
         */
        private static final int INT_PHI = 0x9E3779B9;
        /**
         * The reciprocal of {@link #INT_PHI} modulo 2<sup>32</sup>.
         */
        private static final int INV_INT_PHI = 0x144cbc89;
        /**
         * 2<sup>64</sup> &middot; &phi;, &phi; = (&#x221A;5 &minus; 1)/2.
         */
        private static final long LONG_PHI = 0x9E3779B97F4A7C15L;
        /**
         * The reciprocal of {@link #LONG_PHI} modulo 2<sup>64</sup>.
         */
        private static final long INV_LONG_PHI = 0xF1DE83E19937733DL;

        /**
         * Avalanches the bits of an integer by applying the finalisation step of MurmurHash3.
         * <br>
         * <br>This method implements the finalisation step of Austin Appleby's <a href="http://code.google.com/p/smhasher/">MurmurHash3</a>.
         * Its purpose is to avalanche the bits of the argument to within 0.25% bias.
         *
         * @param x an integer.
         * @return a hash value with good avalanching properties.
         */
        static int murmurHash3(int x) {
            x ^= x >>> 16;
            x *= 0x85ebca6b;
            x ^= x >>> 13;
            x *= 0xc2b2ae35;
            x ^= x >>> 16;
            return x;
        }


        /**
         * Avalanches the bits of a long integer by applying the finalisation step of MurmurHash3.
         * <br>
         * <br>This method implements the finalisation step of Austin Appleby's <a href="http://code.google.com/p/smhasher/">MurmurHash3</a>.
         * Its purpose is to avalanche the bits of the argument to within 0.25% bias.
         *
         * @param x a long integer.
         * @return a hash value with good avalanching properties.
         */
        static long murmurHash3(long x) {
            x ^= x >>> 33;
            x *= 0xff51afd7ed558ccdL;
            x ^= x >>> 33;
            x *= 0xc4ceb9fe1a85ec53L;
            x ^= x >>> 33;
            return x;
        }

        /**
         * Quickly mixes the bits of an integer.
         * <br>This method mixes the bits of the argument by multiplying by the golden ratio and
         * xorshifting the result. It is borrowed from <a href="https://github.com/OpenHFT/Koloboke">Koloboke</a>, and
         * it has slightly worse behaviour than {@link #murmurHash3(int)} (in open-addressing hash tables the average number of probes
         * is slightly larger), but it's much faster.
         *
         * @param x an integer.
         * @return a hash value obtained by mixing the bits of {@code x}.
         * @see #invMix(int)
         */
        static int mix(final int x) {
            final int h = x * INT_PHI;
            return h ^ (h >>> 16);
        }

        /**
         * The inverse of {@link #mix(int)}. This method is mainly useful to create unit tests.
         *
         * @param x an integer.
         * @return a value that passed through {@link #mix(int)} would give {@code x}.
         */
        static int invMix(final int x) {
            return (x ^ x >>> 16) * INV_INT_PHI;
        }

        /**
         * Quickly mixes the bits of a long integer.
         * <br>This method mixes the bits of the argument by multiplying by the golden ratio and
         * xorshifting twice the result. It is borrowed from <a href="https://github.com/OpenHFT/Koloboke">Koloboke</a>, and
         * it has slightly worse behaviour than {@link #murmurHash3(long)} (in open-addressing hash tables the average number of probes
         * is slightly larger), but it's much faster.
         *
         * @param x a long integer.
         * @return a hash value obtained by mixing the bits of {@code x}.
         */
        static long mix(final long x) {
            long h = x * LONG_PHI;
            h ^= h >>> 32;
            return h ^ (h >>> 16);
        }

        /**
         * The inverse of {@link #mix(long)}. This method is mainly useful to create unit tests.
         *
         * @param x a long integer.
         * @return a value that passed through {@link #mix(long)} would give {@code x}.
         */
        static long invMix(long x) {
            x ^= x >>> 32;
            x ^= x >>> 16;
            return (x ^ x >>> 32) * INV_LONG_PHI;
        }

        /**
         * Return the least power of two greater than or equal to the specified value.
         * <br>Note that this function will return 1 when the argument is 0.
         *
         * @param x an integer smaller than or equal to 2<sup>30</sup>.
         * @return the least power of two greater than or equal to the specified value.
         */
        static int nextPowerOfTwo(int x) {
            if (x == 0) return 1;
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            return (x | x >> 16) + 1;
        }

        /**
         * Return the least power of two greater than or equal to the specified value.
         * <br>Note that this function will return 1 when the argument is 0.
         *
         * @param x a long integer smaller than or equal to 2<sup>62</sup>.
         * @return the least power of two greater than or equal to the specified value.
         */
        static long nextPowerOfTwo(long x) {
            if (x == 0) return 1;
            x--;
            x |= x >> 1;
            x |= x >> 2;
            x |= x >> 4;
            x |= x >> 8;
            x |= x >> 16;
            return (x | x >> 32) + 1;
        }

        /**
         * Returns the least power of two larger than or equal to <code>Math.ceil( expected / f )</code>.
         *
         * @param expected the expected number of elements in a hash table.
         * @param f        the load factor.
         * @return the minimum possible size for a backing big array.
         */
        static long bigArraySize(final long expected, final float f) {
            return nextPowerOfTwo((long) Math.ceil(expected / f));
        }
    }

    /**
     * Unwraps an iterator into an array starting at a given offset for a given number of elements.
     * <p>
     * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
     * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
     *
     * @param i      a type-specific iterator.
     * @param array  an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max    the maximum number of elements to unwrap.
     * @return the number of elements unwrapped.
     */
    private int unwrap(final ValueIterator i, final Object[] array, int offset, final int max) {
        if (max < 0) throw new IllegalArgumentException("The maximum number of elements (" + max + ") is negative");
        if (offset < 0 || offset + max > array.length) throw new IllegalArgumentException();
        int j = max;
        while (j-- != 0 && i.hasNext())
            array[offset++] = i.next();
        return max - j - 1;
    }

    /**
     * Unwraps an iterator into an array.
     * <p>
     * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
     * of the array has been reached.
     *
     * @param i     a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped.
     */
    private int unwrap(final ValueIterator i, final Object[] array) {
        return unwrap(i, array, 0, array.length);
    }


    /** Unwraps an iterator into an array starting at a given offset for a given number of elements.
     *
     * <P>This method iterates over the given type-specific iterator and stores the elements returned, up to a maximum of <code>length</code>, in the given array starting at <code>offset</code>. The
     * number of actually unwrapped elements is returned (it may be less than <code>max</code> if the iterator emits less than <code>max</code> elements).
     *
     * @param i a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @param offset the first element of the array to be returned.
     * @param max the maximum number of elements to unwrap.
     * @return the number of elements unwrapped. */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[], int offset, final int max ) {
        if ( max < 0 ) throw new IllegalArgumentException( "The maximum number of elements (" + max + ") is negative" );
        if ( offset < 0 || offset + max > array.length ) throw new IllegalArgumentException();
        int j = max;
        while ( j-- != 0 && i.hasNext() )
            array[ offset++ ] = i.next();
        return max - j - 1;
    }

    /** Unwraps an iterator into an array.
     *
     * <P>This method iterates over the given type-specific iterator and stores the elements returned in the given array. The iteration will stop when the iterator has no more elements or when the end
     * of the array has been reached.
     *
     * @param i a type-specific iterator.
     * @param array an array to contain the output of the iterator.
     * @return the number of elements unwrapped. */
    private static <K> int objectUnwrap(final Iterator<? extends K> i, final K array[] ) {
        return objectUnwrap(i, array, 0, array.length );
    }

    @Override
    public String toString() {
        final StringBuilder s = new StringBuilder();
        int n = size(), i = 0;
        boolean first = true;
        s.append("MirrorSet{");
        while (i < n) {
            if (first) first = false;
            else s.append(", ");
            s.append(entryAt(i++));
        }
        s.append("}");
        return s.toString();
    }
    @Override
    public boolean equals(Object o) {
        if (o == this)
            return true;
        if (!(o instanceof Map))
            return false;
        Map<?, ?> m = (Map<?, ?>) o;
        if (m.size() != size())
            return false;
        return entrySet().containsAll(m.entrySet());
    }

    @GwtIncompatible
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        final K key[] = this.key;
        final int[] value = this.value;
        final MapIterator i = new MapIterator();
        s.defaultWriteObject();
        s.writeObject(hasher);
        for (int j = size, e; j-- != 0;) {
            e = i.nextEntry();
            s.writeObject(key[e]);
            s.writeInt(value[e]);
        }
    }
    @GwtIncompatible
    @SuppressWarnings("unchecked")
    private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        hasher = (CrossHash.IHasher) s.readObject();
        n = arraySize(size, f);
        maxFill = maxFill(n, f);
        mask = n - 1;
        final K key[] = this.key = (K[]) new Object[n + 1];
        final int[] value = this.value = new int[n + 1];
        final IntVLA order = this.order = new IntVLA(n + 1);
        int prev = -1;
        first = last = -1;
        K k;
        int v;
        for (int i = size, pos; i-- != 0;) {
            k = (K) s.readObject();
            v = s.readInt();
            if (k == null) {
                pos = n;
                containsNullKey = true;
            } else {
                pos = HashCommon.mix(hasher.hash(k))
                        & mask;
                while (!(key[pos] == null))
                    pos = (pos + 1) & mask;
            }

            key[pos] = k;
            value[pos] = v;
            if (first != -1) {
                prev = pos;
            } else {
                prev = first = pos;
            }
            order.add(pos);
        }
        last = prev;
    }

    /**
     * Gets the value at the given index in the iteration order in constant time (random-access).
     * @param idx the index in the iteration order of the value to fetch
     * @return the value at the index, if the index is valid, otherwise the default return value
     */
    public int getAt(final int idx) {
        int pos;
        if (idx < 0 || idx >= order.size)
            return defRetValue;
        // The starting point.
        if (key[pos = order.get(idx)] == null)
            return containsNullKey ? value[n] : defRetValue;
        return value[pos];
    }
    /**
     * Gets the key at the given index in the iteration order in constant time (random-access).
     * @param idx the index in the iteration order of the key to fetch
     * @return the key at the index, if the index is valid, otherwise null
     */
    public K keyAt(final int idx) {
        if (idx < 0 || idx >= order.size)
            return null;
        // The starting point.
        return key[order.get(idx)];
    }

    /**
     * Gets the key-value Map.Entry at the given index in the iteration order in constant time (random-access).
     * @param idx the index in the iteration order of the entry to fetch
     * @return the key-value entry at the index, if the index is valid, otherwise null
     */
    public Entry<K, Integer> entryAt(final int idx)
    {
        if (idx < 0 || idx >= order.size)
            return null;
        return new MapEntry(order.get(idx));
    }

    /**
     * Removes the key and value at the given index in the iteration order in not-exactly constant time (though it still
     * should be efficient).
     * @param idx the index in the iteration order of the key and value to remove
     * @return the key removed, if there was anything removed, or null otherwise
     */
    public K removeAt(final int idx) {

        if (idx < 0 || idx >= order.size)
            return null;
        int pos = order.get(idx);
        K k;
        if ((k = key[pos]) == null) {
            if (containsNullKey) {
                removeNullEntry();
            }
            return null;
        }
        removeEntry(pos);
        return k;
    }

    /**
     * Equivalent to {@link #add(Object)}, except that it can place k at any point in the ordering (shifting up later
     * entries and changing their values to match their new positions in the ordering).
     * @param idx the position in the ordering to place k at; will not be used if negative or greater than the current size (it can be equal to the current size)
     * @param k the key to add into this MirrorSet; its value will be idx
     * @return the previous position in the ordering that k had if already present, the previous size of the MirrorSet if k was just added now, or -1 if idx is invalid
     */
    public int addAt(final int idx, final K k) {
        if(idx < 0 || idx > size)
            return -1;
        final int pos = insertAt(k, idx), oldValue = value[pos];
        fixValues(idx);
        if (pos < 0)
            return size - 1;
        return oldValue;
    }
    /**
     * Gets a random value from this MirrorSet in constant time, using the given RNG to generate a random number.
     * @param rng used to generate a random index for a value
     * @return a random value from this MirrorSet, or -1 if this is empty
     */
    public int randomValue(RNG rng)
    {
        if(rng == null)
            return defRetValue;
        return getAt(rng.nextInt(order.size));
    }

    /**
     * Gets a random key from this MirrorSet in constant time, using the given RNG to generate a random number.
     * @param rng used to generate a random index for a key
     * @return a random key from this MirrorSet, or null if this is empty
     */
    public K randomKey(RNG rng)
    {
        if(rng == null)
            return null;
        return keyAt(rng.nextInt(order.size));
    }

    /**
     * Gets a random entry from this MirrorSet in constant time, using the given RNG to generate a random number.
     * @param rng used to generate a random index for a entry
     * @return a random key-value entry from this MirrorSet
     */
    public Entry<K, Integer> randomEntry(RNG rng)
    {
        return new MapEntry(order.getRandomElement(rng));
    }

    /**
     * Randomly alters the iteration order for this MirrorSet using the given RNG to shuffle.
     * @param rng used to generate a random ordering
     * @return this for chaining
     */
    public MirrorSet<K> shuffle(RNG rng)
    {
        if(size < 2)
            return this;
        order.shuffle(rng);
        first = order.get(0);
        last = order.peek();
        fixValues(0);
        return this;
    }

    /**
     * Given an array or varargs of replacement indices for this MirrorSet's iteration order, reorders this so the
     * first item in the returned version is the same as {@code getAt(ordering[0])} (with some care taken for negative
     * or too-large indices), the second item in the returned version is the same as {@code getAt(ordering[1])}, etc.
     * <br>
     * Negative indices are considered reversed distances from the end of ordering, so -1 refers to the same index as
     * {@code ordering[ordering.length - 1]}. If ordering is smaller than {@code size()}, only the indices up to the
     * length of ordering will be modified. If ordering is larger than {@code size()}, only as many indices will be
     * affected as {@code size()}, and reversed distances are measured from the end of this Map's entries instead of
     * the end of ordering. Duplicate values in ordering will produce duplicate values in the returned Map.
     * <br>
     * This method modifies this MirrorSet in-place and also returns it for chaining.
     * @param ordering an array or varargs of int indices, where the nth item in ordering changes the nth item in this
     *                 Map to have the value currently in this Map at the index specified by the value in ordering
     * @return this for chaining, after modifying it in-place
     */
    public MirrorSet<K> reorder(int... ordering)
    {
        if(ordering == null || ordering.length <= 0)
            return this;
        order.reorder(ordering);
        first = order.get(0);
        last = order.peek();
        fixValues(0);
        return this;
    }
    private int alterEntry(final int pos, final K replacement) {
        key[pos] = null;

        final int[] value = this.value;
        int v = value[pos];
        value[pos] = -1;

        int rep;
        if (replacement == null) {
            if (containsNullKey)
                return v;
            rep = n;
            containsNullKey = true;
        } else {
            K curr;
            final K[] key = this.key;

            // The starting point.
            if (!((curr = key[rep = HashCommon.mix(hasher.hash(replacement)) & mask]) == null)) {
                if (curr.equals(replacement))
                    return v;
                while (!((curr = key[rep = (rep + 1) & mask]) == null))
                    if (curr.equals(replacement))
                        return v;
            }
            key[rep] = replacement;
            value[rep] = v;
        }
        fixOrder(pos, rep);
        return v;
    }
    private int alterNullEntry(final K replacement) {
        containsNullKey = false;
        key[n] = null;
        final int[] value = this.value;
        int v = value[n];
        value[n] = -1;

        int rep;
        if (replacement == null) {
            rep = n;
            containsNullKey = true;
        } else {
            K curr;
            final K[] key = this.key;
            // The starting point.
            if ((curr = key[rep = HashCommon.mix(hasher.hash(replacement)) & mask]) != null) {
                if (curr.equals(replacement))
                    return v;
                while ((curr = key[rep = (rep + 1) & mask]) != null)
                    if (curr.equals(replacement))
                        return v;
            }
            key[rep] = replacement;
            value[rep] = v;

        }
        fixOrder(n, rep);
        return v;
    }

    /**
     * Swaps a key, original, for another key, replacement, while keeping replacement at the same point in the iteration
     * order as original and keeping it associated with the same value (which also keeps its iteration index).
     * @param original the key to find and swap out
     * @param replacement the key to replace original with
     * @return the value associated with original before, and replacement now
     */
    public int alter(final K original, final K replacement) {
        if (original == null) {
            if (containsNullKey) {
                return alterNullEntry(replacement);
            }
            else
                return add(replacement);
        }
        else if(original.equals(replacement))
            return getInt(original);
        K curr;
        final K[] key = this.key;
        int pos;
        // The starting point.
        if ((curr = key[pos = HashCommon.mix(hasher.hash(original)) & mask]) == null)
            return add(replacement);
        if (original.equals(curr))
            return alterEntry(pos, replacement);
        while (true) {
            if ((curr = key[pos = (pos + 1) & mask]) == null)
                return add(replacement);
            if (original.equals(curr))
                return alterEntry(pos, replacement);
        }
    }

    public IntVLA getMany(Iterable<K> keys)
    {
        if(keys == null)
            return new IntVLA();
        IntVLA vals = new IntVLA();
        for(K k : keys)
        {
            vals.add(getInt(k));
        }
        return vals;
    }

    public OrderedSet<K> keysAt(int... positions)
    {
        if(keys == null || positions == null || positions.length <= 0)
            return new OrderedSet<K>();
        OrderedSet<K> ks = new OrderedSet<>(positions.length);
        for(int i = 0; i < positions.length; i++)
        {
            ks.add(keyAt(positions[i]));
        }
        return ks;
    }
    public OrderedSet<K> keysAt(IntVLA positions)
    {
        if(keys == null || positions == null || positions.size <= 0)
            return new OrderedSet<K>();
        OrderedSet<K> ks = new OrderedSet<>(positions.size);
        for(int i = 0; i < positions.size; i++)
        {
            ks.add(keyAt(positions.get(i)));
        }
        return ks;
    }

    /**
     * Produces a copy of this MirrorSet, but only using up to the given amount of items to take. Does a shallow copy
     * of individual keys, so the references will be shared.
     * @param amount the number of items to copy from this MirrorSet; will copy all items if greater than size
     * @return a new MirrorSet with up to amount items copied from this into it.
     */
    public MirrorSet<K> take(int amount)
    {
        amount = Math.min(size, Math.max(0, amount));
        MirrorSet<K> nx = new MirrorSet<>(amount, f);
        for (int i = 0; i < amount; i++) {
            nx.add(keyAt(i));
        }
        return nx;
    }
}
